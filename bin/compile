#!/bin/bash
# usage: bin/compile <build-dir> <cache-dir> <env-dir>

set -eo pipefail

mkdir -p "$1" "$2"
build=$(cd "$1/" && pwd)
cache=$(cd "$2/" && pwd)
env_dir="${3}"

buildpack=$(cd "$(dirname $0)/.." && pwd)
source "${buildpack}/lib/common.sh"
ensureFile "jq-linux64" "${cache}/.jq/bin"

DefaultGoVersion="$(<${DataJSON} jq -r '.Go.DefaultVersion')"
GlideVersion="$(<${DataJSON} jq -r '.Glide.DefaultVersion')"
GovendorVersion="$(<${DataJSON} jq -r '.Govendor.DefaultVersion')"
GBVersion="$(<${DataJSON} jq -r '.GB.DefaultVersion')"
PkgErrorsVersion="0.7.1"
MercurialVersion="3.9"
# BazaarVersion="2.7.0"

# For specified versions of Go we need to keep concurrency.sh
needConcurrency() {
  <"${DataJSON}" jq -e '.Go.NeedsConcurrency | indices(["'${1}'"]) | length | if . == 0 then false else true end' &> /dev/null
  return $?
}

handleDefaultPkgSpec() {
  if [ "${pkgs}" = "default" ]; then
    warn "Installing package '.' (default)"
    warn ""
    case "${TOOL}" in
      govendor)
        warn "To install a different package spec set 'heroku.install' in 'vendor/vendor.json'"
        warn ""
        warn "For more details see: https://devcenter.heroku.com/articles/go-apps-with-govendor#build-configuration"
      ;;
      glide)
        warn "To install a different package spec for the next build run:"
        warn ""
        warn "'heroku config:set GO_INSTALL_PACKAGE_SPEC=\"<pkg spec>\"'"
        warn ""
        warn "For more details see: https://devcenter.heroku.com/articles/go-dependencies-via-glide"
      ;;
    esac
    warn ""
    pkgs="."
  fi
}

massagePkgSpecForVendor() {
    local t=""
    for pkg in $(echo $pkgs); do
      if [ "${pkg:0:1}" = "." ] || [ ! -d "./vendor/$pkg" ]; then
        t+="${pkg} "
      else
        t+="${name}/vendor/${pkg} "
      fi
    done
    pkgs="${t}"
}

# TODO: go1 is missing from storage.googleapis.com and we haven't manually compiled it yet
urlFor() {
    local ver=$1
    case $ver in
    devel*)
        local sha=$(echo ${ver} | cut -d - -f 2)  #assumes devel-<short sha> or devel-<full sha>
        echo https://github.com/golang/go/archive/$sha.tar.gz
    ;;
    *)
        local file="${ver}.linux-amd64.tar.gz"
        echo ${BucketURL}/${file}
        ;;
    esac
}

# Expand to supported versions of Go, see data.json for supported expansions.
# All others are returned as is.
expandVer() {
    echo $(<${DataJSON} jq -r 'if .Go.VersionExpansion."'${1}'" then .Go.VersionExpansion."'${1}'" else "'${1}'" end')
}

# Report deprecated versions to user
# Use after expandVer
reportVer() {
  if <"${DataJSON}" jq -e '.Go.Supported | indices(["'${1}'"]) | length | if . > 0 then true else false end' &> /dev/null; then
    return
  fi
  case $1 in
  devel*)
    warn ""
    warn "You are using a development build of Go."
    warn "This is provided for users requiring an unreleased Go version"
    warn "but is otherwise unsupported."
    warn ""
    warn "Build tests are NOT RUN!!"
    warn ""
    ;;
  *)
    warn ""
    warn "Deprecated or unsupported version of go ($1)"
    warn "See https://devcenter.heroku.com/articles/go-support#go-versions for supported version information."
    warn ""
    ;;
  esac
}

ensureHG() {
    local hgv="${1}"
    local thgp=$(mktemp -d)
    local hgp="${cache}/hg/${hgv}"
    #local hgb="${hgp}/hg"
    if test -d "${hgp}"
    then
        step "Using hg v${hgv}"
    else
        rm -rf "${cache}/hg"
        mkdir -p "${hgp}"
        start "Installing hg ${hgv}"
          $CURL "https://www.mercurial-scm.org/release/mercurial-${hgv}.tar.gz" | tar -zxf - --strip-components=1 -C ${thgp}
          pushd "${thgp}" &> /dev/null
          python setup.py install --force --home=${hgp} &> /dev/null
          popd &> /dev/null
        finished
    fi

    PATH="${hgp}/bin:${PATH}"
}

ensureBZR() {
    local bzrv="${1}"
    local bzrvs=$(echo ${bzrv} | cut -d . -f 1,2)
    local tbzrp=$(mktemp -d)
    local bzrp="${cache}/bzr/${bzrv}"
    if [ -d "${bzrp}" ]; then
      step "Using bzr v${bzrv}"
    else
      rm -rf "${cache}/bzr"
      mkdir -p "${bzrp}"
      start "Installing bzr ${bzrv}"
        $CURL "https://launchpad.net/bzr/${bzrvs}/${bzrv}/+download/bzr-${bzrv}.tar.gz" | tar -zxf - --strip-components=1 -C ${tbzrp}
        pushd "${tbzrp}" &> /dev/null
        python setup.py install --force --home=${bzrp} &> /dev/null
        popd &> /dev/null
      finished
    fi

    PATH="${bzrp}/bin:${PATH}"
    export PYTHONPATH="${bzrp}/lib/python:${PYTHONPATH}"
}

ensureGlide() {
    local gv=${1}
    local gvPath="${cache}/glide/${gv}/bin"
    local gvBin="${gvPath}/glide"

    if [ -d "${gvPath}" ]; then
      step "Using glide ${gv}"
    else
      rm -rf "${cache}/glide"
      mkdir -p "${gvPath}"
      start "Installing glide ${gv}"
        $CURL "https://github.com/Masterminds/glide/releases/download/${gv}/glide-${gv}-linux-amd64.tar.gz" | tar -zxf - --strip-components=1 -C ${gvPath}
        chmod a+x ${gvBin}
      finished
    fi

    PATH="${gvPath}:${PATH}"
}

setGoVersionFromEnvironment() {
  if [ -z "${GOVERSION}" ]; then
    warn ""
    warn "'GOVERSION' isn't set, defaulting to '${DefaultGoVersion}'"
    warn ""
    warn "Run 'heroku config:set GOVERSION=goX.Y' to set the Go version to use"
    warn "for future builds"
    warn ""
  fi
  ver=${GOVERSION:-$DefaultGoVersion}
}

warnGoVersionOverride() {
  if [ ! -z "${GOVERSION}" ]; then
    warn "Using \$GOVERSION override."
    warn "     \$GOVERSION = ${GOVERSION}"
    warn ""
    warn "If this isn't what you want please run:'"
    warn "  heroku config:unset GOVERSION -a <app>"
    warn ""
  fi
}

warnPackageSpecOverride() {
  if [ ! -z "${GO_INSTALL_PACKAGE_SPEC}" ]; then
    warn "Using \$GO_INSTALL_PACKAGE_SPEC override."
    warn "     \$GO_INSTALL_PACKAGE_SPEC = ${GO_INSTALL_PACKAGE_SPEC}"
    warn ""
    warn "If this isn't what you want please run:'"
    warn "  heroku config:unset GO_INSTALL_PACKAGE_SPEC -a <app>"
    warn ""
  fi
}

# Sets up GOPATH (and posibly other GO* env vars) and returns the location of
# the source code as $src. The output of this function is meant to be eval'd'
setupGOPATH() {
    local name="${1}"
    local t="$(mktemp -d)"

    if [ "${GO_SETUP_GOPATH_IN_IMAGE}" = "true" ]; then
      mv -t ${t} ${build}/*
      GOPATH="${build}"
    else
      cp -R ${build}/* ${t}
      GOPATH="${t}/.go"
      echo export GOBIN="${build}/bin"
    fi

    local src="${GOPATH}/src/${name}"
    mkdir -p "${src}"
    mv -t "${src}" "${t}"/*

    echo "GOPATH=${GOPATH}"
    echo "src=${src}"
}

loadEnvDir "${env_dir}"
determineTool

ver=$(expandVer $ver)
url=${GOURL:-$(urlFor $ver)}

if [ -e "${build}/bin" -a ! -d "${build}/bin" ]; then
  err ""
  err "File bin exists and is not a directory."
  err ""
  exit 1
fi

reportVer $ver

if [ -d "${cache}/${ver}/go" ]; then
  step "Using ${ver}"
else
  rm -rf ${cache}/* # be sure not to build up cruft
  mkdir -p "${cache}/${ver}"
  pushd "${cache}/${ver}" > /dev/null
  start "Installing ${ver}"
    ${CURL} ${url} | tar zxf -
  finished
  case "${ver}" in  # Rename 'go-<full sha>' (we have the short sha) to 'go'
    devel*)
      bver=$(expandVer ${DefaultGoVersion})
      burl=$(urlFor ${bver})
      start "Installing bootstrap Go version ${bver}"
        ${CURL} ${burl} | tar zxf -
      finished
      mv go bgo
      mv go-$(echo ${ver} | cut -d - -f 2)* go
      step "Compiling development Go version $ver..."
        pushd go/src > /dev/null
        echo "devel +$(echo ${ver} | cut -d - -f 2) $(date "+%a %b %H:%M:%S %G %z")"> ../VERSION
        GOROOT_BOOTSTRAP=$(pushd ${cache}/${ver}/bgo > /dev/null; pwd; popd > /dev/null) ./make.bash 2>&1
        popd > /dev/null
        go/bin/go version
      finished
      rm -rf bgo
    ;;
  esac
  popd > /dev/null
fi

mkdir -p $build/bin
export GOROOT="${cache}/${ver}/go"
PATH="${PATH}:${GOROOT}/bin"

# If $GO_LINKER_SYMBOL and GO_LINKER_VALUE are set, tell the linker to DTRT
FLAGS=(-tags heroku)
if [ -n "${GO_LINKER_SYMBOL}" -a -n "${GO_LINKER_VALUE}" ]; then
  case "${ver}" in
    go1.0*|go1.1*|go1.2*|go1.3*|go1.4*)
      xval="${GO_LINKER_SYMBOL} ${GO_LINKER_VALUE}"
    ;;
    *)
      xval="${GO_LINKER_SYMBOL}=${GO_LINKER_VALUE}"
    ;;
  esac
  FLAGS=(${FLAGS[@]} -ldflags "-X ${xval}")
fi

export GOPATH

# GB installation
case "${TOOL}" in
  godep)
    eval "$(setupGOPATH ${name})"
    godepsJSON="${src}/Godeps/Godeps.json"

    pkgs=${GO_INSTALL_PACKAGE_SPEC:-$(<${godepsJSON} jq -r 'if .Packages then .Packages | join(" ") else "default" end')}
    warnPackageSpecOverride
    handleDefaultPkgSpec

    UseGodepCommand="false" # Default to not wrapping go install with godep (vendor)

    if <"${DataJSON}" jq -e '.Go.SupportsVendorExperiment | indices(["'${ver}'"]) | length | if . == 0 then false else true end' &> /dev/null; then
      case "${ver}" in
        go1.5*) #go1.5* defaults to disable vendor
          if [ -z "${GO15VENDOREXPERIMENT}" -o "${GO15VENDOREXPERIMENT}" = "0" ]; then
            UseGodepCommand="true"
          fi
        ;;
        go1.6*) #go1.6* defaults to enable vendor
          if [ "${GO15VENDOREXPERIMENT}" = "0" ]; then
            UseGodepCommand="true"
          fi
        ;;
      esac
    else
      if [ -n "${GO15VENDOREXPERIMENT}" ]; then
        err ""
        err "GO15VENDOREXPERIMENT is set, but is not supported by ${ver}"
        err "run `heroku config:unset GO15VENDOREXPERIMENT`"
        err "before pushing again."
        err ""
        exit 1
      fi
    fi

    unset GIT_DIR # unset git dir or it will mess with goinstall
    cd "${src}"
    if [ "${UseGodepCommand}" = "true" ]; then
      step "Running: godep go install -v ${FLAGS[@]} ${pkgs}"
      godep go install -v "${FLAGS[@]}" ${pkgs} 2>&1
    else
      massagePkgSpecForVendor
      step "Running: go install -v ${FLAGS[@]} ${pkgs}"
      go install -v "${FLAGS[@]}" ${pkgs} 2>&1
    fi
  ;;
  govendor)
    govendorPath="${cache}/govendor/bin"
    govendorBin="${govendorPath}/govendor"
    if [ -d "${govendorBin}" ]; then
      step "Using govendor v${GovendorVersion}"
    else
      rm -rf "${cache}/govendor"
      mkdir -p "${govendorPath}"
      start "Installing govendor v${GovendorVersion}"
        $CURL "https://github.com/kardianos/govendor/releases/download/v${GovendorVersion}/govendor_linux_amd64" > "${govendorBin}"
        chmod a+x "${govendorBin}"
      finished
    fi

    PATH="${govendorPath}:$PATH"
    eval "$(setupGOPATH ${name})"
    vendorJSON="${src}/vendor/vendor.json"

    pkgs=${GO_INSTALL_PACKAGE_SPEC:-$(<${vendorJSON} jq -r 'if .heroku.install then .heroku.install | join(" ") else "default" end')}
    warnPackageSpecOverride
    handleDefaultPkgSpec

    unset GIT_DIR # unset git dir or it will mess with goinstall
    cd "${src}"

    if [ "$(<${vendorJSON} jq -r '.heroku.sync')" != "false" ]; then
      step "Fetching any unsaved dependencies (govendor sync)"
      govendor sync
    fi
    massagePkgSpecForVendor

    step "Running: go install -v ${FLAGS[@]} ${pkgs}"
    go install -v "${FLAGS[@]}" ${pkgs} 2>&1
  ;;
  glide)
    ensureGlide ${GlideVersion}
    ensureHG ${MercurialVersion}
    # ensureBZR ${BazaarVersion}

    # Do this before setupGOPATH as we need ${name} set first
    cd "${build}"
    name=$(glide name 2>/dev/null)

    eval "$(setupGOPATH ${name})"

    pkgs=${GO_INSTALL_PACKAGE_SPEC:-"default"}
    handleDefaultPkgSpec

    unset GIT_DIR
    cd "${src}"

    step "Fetching any unsaved dependencies (glide install)"
    glide install 2>&1

    massagePkgSpecForVendor

    step "Running: go install -v ${FLAGS[@]} ${pkgs}"
    go install -v "${FLAGS[@]}" ${pkgs} 2>&1
  ;;
  gb)
    GOPATH="${cache}/gb/${GBVersion}"
    PATH="${GOPATH}/bin:${PATH}"
    cp="${GOPATH}/src/github.com/constabulary"
    pp="${GOPATH}/src/github.com/pkg"
    if [ -d "${GOPATH}" ]; then
      step "Using GB ${GBVersion}"
    else
      rm -rf "${cache}/gb/*" # cruft bad
      mkdir -p "${pp}"
      cd "${pp}"
      $CURL "https://codeload.github.com/pkg/errors/tar.gz/v${PkgErrorsVersion}" | tar zxf -
      mv "errors-${PkgErrorsVersion}" errors
      mkdir -p "${cp}"
      cd "${cp}"
      start "Installing GB v${GBVersion}"
        $CURL "https://codeload.github.com/constabulary/gb/tar.gz/v${GBVersion}" | tar zxf -
        mv "gb-${GBVersion}" gb
        go install ./...
      finished
    fi

    cd $build
    step "Running: gb build ${FLAGS[@]}"
    gb build "${FLAGS[@]}" 2>&1

    step "Post Compile Cleanup"
    for f in bin/*-heroku; do
      mv "$f" "${f/-heroku}"
    done
    rm -rf pkg
  ;;
esac

if [ -n "${src}" -a "${src}" != "${build}" -a -e "${src}/Procfile" ]; then
  mv -t "${build}" "${src}/Procfile"
fi

if [ ! -e $build/Procfile -a -n "${name}" ]; then
  echo -e "web: $(basename $name)" >> $build/Procfile
fi

cd $build
mkdir -p $build/.profile.d
echo 'PATH=$PATH:$HOME/bin' > $build/.profile.d/go.sh

if [ "${GO_INSTALL_TOOLS_IN_IMAGE}" = "true" ]; then
  start "Copying go tool chain to \$GOROOT=\$HOME/.heroku/go"
    mkdir -p "${build}/.heroku/go"
    cp -a "${GOROOT}/"* "${build}/.heroku/go"
    echo 'export GOROOT=$HOME/.heroku/go' > "${build}/.profile.d/goroot.sh"
    echo 'PATH=$PATH:$GOROOT/bin' >> "${build}/.profile.d/goroot.sh"
  finished
  step "Copying ${TOOL} binary"
  cp $(which ${TOOL}) "${build}/bin"
fi

if [ "${GO_SETUP_GOPATH_IN_IMAGE}" = "true" ]; then
  start "Cleaning up \$GOPATH/pkg"
    rm -rf $GOPATH/pkg
  finished
  echo 'export GOPATH=$HOME' > "${build}/.profile.d/zzgopath.sh"  #Try to make sure it's down in towards the end
  echo 'cd $GOPATH/src/'${name} >> "${build}/.profile.d/zzgopath.sh" # because of this
fi

if needConcurrency ${ver}; then
  cp $buildpack/vendor/concurrency.sh $build/.profile.d/
fi

t="${build}/.heroku/go"
mkdir -p "${t}"
t="${t}/.meta"
echo "TOOL=${TOOL}" > "${t}"
if [ "${TOOL}" != "gb" ]; then
  echo "NAME=${name}" >> "${t}"
fi